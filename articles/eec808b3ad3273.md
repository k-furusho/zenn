---
title: "なぜ country じゃない？ Intl.Locale の region に隠された理由をWEB標準から学んだ話"
emoji: "✈️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ['i18n','intl','locale','frontend']
published: false
publication_name: "dress_code"
---

## はじめに
DRESS CODEのプロダクト開発に奮闘している、ふるしょうです。
グローバル化が進む現代において、Webアプリケーションの国際化（i18n）は、国際的に利用されるSaaSにとって必須の要素です。
DRESS CODEは、日本以外の国・地域でも利用されるため、i18n対応が不可欠です。
運用を進める中で、特にlocaleの扱いに関する疑問が浮かび上がりました。MDNのi18nに関するドキュメントを読み進めていたとき、localeが「country」ではなく「region」として扱われている点に違和感を覚えたのです。

「国を指定するのに、なぜregionという用語なのか？」「countryとregionの違いは何か？」この疑問を解消するため、私はECMAScriptの仕様や関連する国際標準を掘り下げました。その過程で、localeの背後にある複雑な構造と、WEB標準の設計思想に触れることができました。本記事では、その調査で得た知見を共有しつつ、i18n対応に取り組むエンジニアが直面する課題に具体的な視点を紹介します。

## i18nとは？ 
国際化（Internationalization、以下i18n）は、ソフトウェアやWebアプリケーションを多様な言語や地域、文化に適応させるための設計プロセスです。「i18n」の「18」は、"Internationalization"の「I」と「N」の間に18文字あることに由来する略記法で、エンジニアにはお馴染みですね。このプロセスは、単にテキストを翻訳するだけに留まらず、以下のような要素を包括的に扱います：

- 言語: ユーザーが母語でコンテンツを理解できるようにする。  

- 日付と時刻: 日本なら「2023年10月25日」、米国なら「October 25, 2023」のように、地域特有のフォーマットを提供。  

- 通貨: 「¥1,234」や「$1,234.56」など、地域ごとの記号や桁区切りを適用。  

- ソート順: 日本語の「あいうえお」順や、アラビア語の右から左への並びに対応。  

- 文化的配慮: 色（例: 日本では白が純粋さを、米国では黒が喪を象徴）やアイコンの意味を調整。

私が初めてi18nに取り組んだとき、翻訳ファイルを作れば終わりだと考えていました。しかし、実際にはユーザーが「自然に使える」体験を提供するには、これらの要素を丁寧に設計する必要がありました。i18nのゴールは、グローバルなユーザー誰もが自然と直感的に利用できる感覚を与えることです。


## ECMAScriptとlocale
ECMAScriptはJavaScriptの標準仕様であり、WEB開発の基盤となる技術です。localeに関する仕様は、主にECMA-402（Internationalization API Specification）に定義されています。この仕様は、国際化をサポートするための強力なツールを提供し、グローバルなアプリケーション開発を可能にします。


### localeとは何か？

localeとは、ユーザーの言語や地域、文化的な設定を表す識別子です。例えば、「ja-JP」は日本語（日本）を、「en-US」は英語（アメリカ）を示します。localeは、言語コード（ISO 639-1）と地域コード（ISO 3166-1 alpha-2）の組み合わせで構成されることが一般的で、必要に応じてスクリプトやカレンダーなどの追加情報が含まれる場合もあります。
WEBアプリケーションでは、localeを活用することで、ユーザーに適した言語でメッセージを表示したり、地域に応じた日付や通貨のフォーマットを提供したりできます。これにより、ユーザーエクスペリエンスが向上し、国際的な市場での競争力が高まります。

### ECMAScriptにおける国際化の基盤: ECMA-402

ECMAScriptの国際化機能は、ECMA-402で標準化されています。この仕様では、IntlオブジェクトとLocaleオブジェクトが中心的な役割を果たします。以下では、これらのオブジェクトの役割と違いを詳しく見ていきます。

## Intlオブジェクト: 国際化のためのツールボックス

Intlオブジェクトは、JavaScriptのグローバルオブジェクトであり、国際化に関する一連の機能を提供します。主に以下のコンストラクタを通じて、localeに応じたフォーマットや比較を実現します。

- Intl.DateTimeFormat: 日付や時刻のフォーマット
- Intl.NumberFormat: 数値や通貨のフォーマット
- Intl.Collator: 文字列の比較とソート
- Intl.RelativeTimeFormat: 相対的な時間のフォーマット（例: 「2日前」）
- Intl.PluralRules: 複数形のルール処理

これらのコンストラクタは、localeを引数として受け取り、その設定に基づいた結果を返します。たとえば、以下はIntl.DateTimeFormatを使った例です。


```javascript
const date = new Date();
const japaneseFormatter = new Intl.DateTimeFormat("ja-JP");
console.log(japaneseFormatter.format(date)); // 日本式の日付フォーマット

const usFormatter = new Intl.DateTimeFormat("en-US");
console.log(usFormatter.format(date)); // "10/10/2023"
```

このように、Intlオブジェクトはlocaleに応じた柔軟なフォーマットを提供し、国際化の基盤となります。


## Intl.Localeオブジェクト
Intl.Localeは、特定のlocaleをオブジェクトとして表現するためのコンストラクタです。Intlオブジェクトが機能を提供するのに対し、Localeオブジェクトはlocaleの詳細な情報を保持し、開発者がそれを操作・参照できるようにします。

### Localeオブジェクトの基本的な使い方

以下は、Localeオブジェクトを作成し、そのプロパティにアクセスする例です。

```javascript
const locale = new Intl.Locale("ja-JP");
console.log(locale.language); // "ja"（言語コード）
console.log(locale.region); // "JP"（地域コード）
console.log(locale.toString()); // "ja-JP"（locale全体）
```

### 主なプロパティ
Localeオブジェクトは、以下のようなプロパティを持ちます。
- language: 言語コード（例: "ja"）
- region: 地域コード（例: "JP"）
- script: スクリプトコード（例: "Latn"）
- baseName: 基本的なlocale名（例: "ja-JP"）
- calendar: 使用するカレンダー（例: "gregory"）
- numberingSystem: 数値システム（例: "latn"）

これらのプロパティは、localeの構成要素を分解してアクセスする際に役立ちます。
私が驚いたのは、Localeが単なるデータホルダーではなく、拡張性を持った設計だということ。たとえば、カレンダーを指定する-u-ca-のようなオプションを扱えるのは、Intl単体では難しい柔軟性です。

## IntlとLocaleの違いと連携
IntlとLocaleは、それぞれ異なる役割を持ちながら、連携して国際化を実現します。
- Intl: 機能を提供する枠組み。locale情報を引数として受け取り、フォーマットや比較を実行。
- Locale: localeそのものを表現するオブジェクト。詳細な情報を保持し、必要に応じてIntlに渡される。

たとえば、LocaleオブジェクトをIntlコンストラクタに渡して使うことができます。

```javascript
const locale = new Intl.Locale("fr-FR");
const formatter = new Intl.DateTimeFormat(locale);
console.log(formatter.format(new Date())); // "10/10/2023"（フランス式）
```

このように、Localeで定義したロケールをIntlで活用することで、柔軟かつ正確な国際化が可能になります。

## region vs country: なぜ「region」なのか？
私がi18nに取り組む中で最も引っかかったのは、IntlやLocaleが「country」ではなく「region」という言葉を使う点です。直感的には「国＝country」でいいじゃないか、と感じますよね。しかし、ECMAScriptやWEB標準を調べていくと、この選択には深い理由がありました。


### BCP 47：言語タグの基盤

Intlの設計は、BCP 47（RFC 5646 Tags for Identifying Languages）に準拠しています。BCP 47は、言語タグの構造を定義する標準で、localeを「言語＋地域＋スクリプト」などのサブタグで表現します。RFC 5646の原文を見てみましょう：

> **Section 2.2.4 Region Subtag**
The region subtag is used to indicate a geographic area that is associated with the language tag. It can be a country, a territory, or a region that is identified by a code from ISO 3166-1 alpha-2 or from the UN M.49 standard.

訳すと、「regionサブタグは、言語タグに関連する地理的エリアを示すために使われ、国、領土、または地域を指す」とあります。つまり：
- "en-US": 英語（アメリカ合衆国）。  
- "zh-HK": 中国語（香港、領土として）。  
- "es-419": スペイン語（ラテンアメリカ地域、UN M.49のコード）。

この「region」が国に限定されない点がポイントです。たとえば「419」は特定の国ではなく、ラテンアメリカ全体を指します。原文の「It can be a country, a territory, or a region」という柔軟性が、countryではなくregionを採用した理由なんですね。

### ISO 3166-1とUN M.49：地域コードの裏側
regionサブタグは、具体的に以下の規格に基づいています：

- [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html): 国や領土の2文字コードを定義。「JP」（日本）、「HK」（香港）などがこれに該当。 
    - 原文: "ISO 3166-1 provides a list of two-letter country codes intended for use in applications requiring a stable coding system."  
    - 解説: 安定したコード体系を提供する目的で、国だけでなく領土も含まれるため、「country」より広い概念が必要でした。
- UN M.49: 国連の統計用地域コード。「001」（世界）、「019」（アメリカ大陸）、「419」（ラテンアメリカ）など、広域エリアをカバー。  
    - 原文（UNサイトより）: "M49 is a standard for area codes used by the United Nations for statistical purposes."
    - 解説: 国境を越えた地域を扱うため、「region」が適切とされたわけです。

私が「es-419」を初めて見たとき、「国じゃないの？」と混乱しましたが、UN M.49の存在を知って納得しました。たとえば、ラテンアメリカ向けのスペイン語コンテンツを一括で提供する際、「419」は非常に便利です。

### Unicode拡張：柔軟性の鍵
さらに、[Unicode Technical Standard #35](https://www.unicode.org/reports/tr35/#Locale_Extension_Key_and_Type_Data)では、localeの拡張が定義されています。原文を引用します：

> Section 3.6.1 Locale Extension Key and Type Data
The 'u' extension is used to specify additional attributes of a locale, such as calendar or numbering system. For example, "ja-JP-u-ca-japanese" specifies Japanese calendar.


このように、「-u-」でカレンダーや数値体系を指定できるんです。たとえば：

```javascript
const locale = new Intl.Locale("ja-JP-u-ca-japanese");
console.log(locale.calendar); // "japanese"（和暦）
```

これをIntlで使うと：

```javascript
const formatter = new Intl.DateTimeFormat("ja-JP-u-ca-japanese");
console.log(formatter.format(new Date(2023, 9, 25))); // "令和5年10月25日"
```
「region」が採用されたのは、こうした拡張性と互換性を確保するため。和暦対応を求められるようなケースでは、この仕様が役に立ちます。

### ECMAScriptでの明記

ECMAScriptの国際化API仕様（[ECMA-402](https://tc39.es/ecma402/)）でも、regionの採用が明確です：

> Section 6.2.2 Locale Objects
The region property, if present, is a string whose value is a valid region subtag as defined in BCP 47.


つまり、BCP 47に準拠した「regionサブタグ」を返すと規定されています。この一貫性が、グローバルな互換性を支えているのです。

### なぜ「country」じゃダメだったのか？
- 限定性: 「country」は国だけを指し、領土（香港）や広域（ラテンアメリカ）をカバーできない。  
- 標準とのズレ: ISO 3166-1やUN M.49が「国以上」の概念を扱うため、「region」が適切。  
- 実用性: 開発者が柔軟に地域を扱えるように。


## WEBアプリケーションでのlocaleの取り扱い
WEB開発では、localeを正しく取得し、それに基づいてコンテンツやフォーマットを動的に調整することが求められます。以下に、実践的な手法を紹介します。


1. ブラウザからlocaleを取得
ユーザーのlocaleは、ブラウザの設定から取得できます。JavaScriptでは以下のプロパティが利用可能です。
- navigator.language: ユーザーの優先言語（例: "ja-JP"）
- navigator.languages: 優先言語のリスト（例: ["ja-JP", "en-US"]）

```javascript
const userLocale = navigator.language;
console.log(userLocale); // "ja-JP"（環境依存）
```

2. Network層での国際化
Webアプリケーションでは、ネットワーク層でのlocale情報も重要です。ユーザーの言語や地域の好みは、HTTPのAccept-Languageヘッダーでサーバーに伝わります。

### Accept-Languageの仕様
RFC 7231（HTTP/1.1）に基づくAccept-Languageの例を見てみましょう：
```
Accept-Language: ja-JP, en-US;q=0.9, zh-CN;q=0.8
```
- "ja-JP": 第一優先（q=1とみなす）。  

- "en-US;q=0.9": 第二優先（優先度90%）。  

- "zh-CN;q=0.8": 第三優先（優先度80%）。

原文（RFC 7231）：

> Section 5.3.5 Accept-Language
The "Accept-Language" header field can be used by user agents to indicate the set of natural languages that are preferred in the response. Each language-range can be given an associated quality value representing an estimate of the user's preference.

「ユーザーの好みを表す品質値（q値）」がポイントで、サーバーはこれを基に最適なコンテンツを選びます。


```javascript
import express from 'express';
const app = express();

app.use((req, res, next) => {
  const locale = req.headers['accept-language'] || 'en-US';
  console.log(`User locale: ${locale}`);
  next();
});

app.listen(3000);
```

DRESS CODEでは、独自にそれぞれのレイヤーでの言語の優位性を判定するロジックを国際化対応基盤として用意してフロントエンドアプリケーションとバックエンドサーバーが通信を行い、ユーザーが求める言語体でのコンテンツをブラウザに描画するように設計しています。

3. 国際化ライブラリの活用
localeに応じた翻訳やフォーマットを効率的に行うには、ライブラリが便利です。以下に、i18nextを使った例を示します。

```javascript
import i18next from 'i18next';

i18next.init({
  lng: navigator.language,
  resources: {
    'en-US': { translation: { welcome: 'Welcome!' } },
    'ja-JP': { translation: { welcome: 'ようこそ！' } }
  }
});

console.log(i18next.t('welcome')); // "ようこそ！"（日本語の場合）
```

4. Intlを使ったフォーマットの実践
Intlオブジェクトを活用して、localeに応じたフォーマットを実装できます。

```javascript
const number = 123456.789;
const usFormat = new Intl.NumberFormat("en-US").format(number);
const jpFormat = new Intl.NumberFormat("ja-JP").format(number);

console.log(usFormat); // "123,456.789"
console.log(jpFormat); // "123,456.789"（日本では小数点以下もカンマ区切り）
```

## まとめ
EcmaScriptの最新仕様に基づき、IntlとLocaleを活用したlocaleの取り扱いを解説しました。
- i18nの基本: 言語や文化を越えた設計の重要性。  
- IntlとLocale: 役割の違いと実践的な使い方。  
- "region"の採用理由: BCP 47、ISO 3166-1、UN M.49に基づく柔軟性。  

i18n対応、奥が深い。。。

## 参考文献  


- [RFC 5646 Tags for Identifying Languages](https://datatracker.ietf.org/doc/html/rfc5646)
- [ISO 3166-1 Codes](https://www.iso.org/iso-3166-country-codes.html)
- [Unicode Technical Standard](https://www.unicode.org/reports/tr35/)
- [ECMA-402 Internationalization API](https://tc39.es/ecma402/)
- [RFC 7231 HTTP/1.1 Semantics](https://tools.ietf.org/html/rfc7231)



